//! Diffie-Hellman Key Exchange Protocol
//!
//! This module implements the Diffie-Hellman (DH) key exchange protocol for various
//! algebraic structures:
//! 1. Classic prime field F_p
//! 2. Binary extension field F_2^k
//! 3. Extended prime field F_p^k (p ≥ 3)
//! 4. Elliptic curves over F_p, F_2^k, and F_p^k
//!
//! # Protocol Overview
//!
//! Diffie-Hellman allows two parties to establish a shared secret over an insecure channel:
//!
//! ## Phase 1: Key Generation
//! Each party generates:
//! - **Private key (sk)**: Random integer from Z_q
//! - **Public key (pk)**: Computed as g^sk (or [sk]G for elliptic curves)
//!
//! ## Phase 2: Key Agreement
//! Each party computes the shared secret:
//! - **Shared secret (ss)**: Computed as epk^sk where epk is the other party's public key
//!
//! # Security Considerations
//!
//! - The order q of the generator g (or G) should be prime for security
//! - For DDH-security, g should generate a subgroup of order q, not the full group
//! - Private keys must be randomly generated from a cryptographically secure source
//! - Implementations should use constant-time operations to prevent timing attacks

use crate::elliptic_curve::{EllipticCurve, Point};
use crate::field_trait::FieldElement;
use std::fmt::Debug;

/// Domain parameters for Diffie-Hellman key exchange
///
/// This trait defines the common interface for all DH parameter types.
/// Different algebraic structures have different parameter representations.
pub trait DHDomainParameters: Clone + Debug {
    /// The type of the generator element
    type Generator: Clone + Debug;

    /// The order of the group generated by g (should be prime)
    fn order(&self) -> u64;

    /// The generator element
    fn generator(&self) -> Self::Generator;
}

/// Diffie-Hellman protocol implementation
///
/// This trait defines the DH protocol operations for a specific algebraic structure.
pub trait DiffieHellman {
    /// Domain parameters type
    type Params: DHDomainParameters;

    /// Private key type (typically an integer modulo q)
    type PrivateKey: Clone + Debug;

    /// Public key type (depends on the algebraic structure)
    type PublicKey: Clone + Debug + PartialEq;

    /// Shared secret type (same as public key type)
    type SharedSecret: Clone + Debug + PartialEq;

    /// Generates a new private key
    ///
    /// # Arguments
    /// * `params` - The domain parameters
    /// * `random_value` - A random value in Z_q (in real applications, use cryptographically secure RNG)
    ///
    /// # Returns
    /// A new private key
    fn generate_private_key(params: &Self::Params, random_value: u64) -> Self::PrivateKey;

    /// Computes the public key from a private key
    ///
    /// # Arguments
    /// * `params` - The domain parameters
    /// * `private_key` - The private key
    ///
    /// # Returns
    /// The corresponding public key (g^sk or [sk]G)
    fn compute_public_key(params: &Self::Params, private_key: &Self::PrivateKey)
    -> Self::PublicKey;

    /// Computes the shared secret from our private key and the other party's public key
    ///
    /// # Arguments
    /// * `params` - The domain parameters
    /// * `our_private_key` - Our private key
    /// * `their_public_key` - The other party's public key
    ///
    /// # Returns
    /// The shared secret (epk^sk or [sk]EPK)
    fn compute_shared_secret(
        params: &Self::Params,
        our_private_key: &Self::PrivateKey,
        their_public_key: &Self::PublicKey,
    ) -> Self::SharedSecret;
}

//
// ========================= Prime Field F_p DH =========================
//

/// Domain parameters for DH over prime field F_p
///
/// # Parameters
/// - `p`: The prime modulus
/// - `g`: The generator element in F_p
/// - `q`: The order of the subgroup generated by g (should be prime)
#[derive(Clone, Debug)]
pub struct DHParamsFp<F: FieldElement> {
    pub p_description: String, // Description of the prime (e.g., "97")
    pub g: F,                  // Generator
    pub q: u64,                // Order of subgroup generated by g
}

impl<F: FieldElement + std::fmt::Debug> DHDomainParameters for DHParamsFp<F> {
    type Generator = F;

    fn order(&self) -> u64 {
        self.q
    }

    fn generator(&self) -> Self::Generator {
        self.g.clone()
    }
}

/// Diffie-Hellman over prime field F_p
pub struct DHFp<F: FieldElement> {
    _phantom: std::marker::PhantomData<F>,
}

impl<F: FieldElement + std::fmt::Debug> DiffieHellman for DHFp<F> {
    type Params = DHParamsFp<F>;
    type PrivateKey = u64;
    type PublicKey = F;
    type SharedSecret = F;

    fn generate_private_key(params: &Self::Params, random_value: u64) -> Self::PrivateKey {
        // Private key should be in [1, q-1]
        1 + (random_value % (params.q - 1))
    }

    fn compute_public_key(
        params: &Self::Params,
        private_key: &Self::PrivateKey,
    ) -> Self::PublicKey {
        // pk = g^sk mod p
        let sk_bytes = private_key.to_le_bytes();
        params.g.pow(&sk_bytes)
    }

    fn compute_shared_secret(
        _params: &Self::Params,
        our_private_key: &Self::PrivateKey,
        their_public_key: &Self::PublicKey,
    ) -> Self::SharedSecret {
        // ss = epk^sk mod p
        let sk_bytes = our_private_key.to_le_bytes();
        their_public_key.pow(&sk_bytes)
    }
}

//
// ========================= Binary Field F_2^k DH =========================
//

/// Domain parameters for DH over binary field F_2^k
///
/// # Parameters
/// - `m`: Coefficients of the irreducible polynomial (bit string)
/// - `g`: The generator element in F_2^k
/// - `q`: The order of the subgroup generated by g
#[derive(Clone, Debug)]
pub struct DHParamsF2k<F: FieldElement> {
    pub k: usize,              // Extension degree
    pub m_description: String, // Description of irreducible polynomial
    pub g: F,                  // Generator
    pub q: u64,                // Order of subgroup
}

impl<F: FieldElement + std::fmt::Debug> DHDomainParameters for DHParamsF2k<F> {
    type Generator = F;

    fn order(&self) -> u64 {
        self.q
    }

    fn generator(&self) -> Self::Generator {
        self.g.clone()
    }
}

/// Diffie-Hellman over binary field F_2^k
pub struct DHF2k<F: FieldElement> {
    _phantom: std::marker::PhantomData<F>,
}

impl<F: FieldElement + std::fmt::Debug> DiffieHellman for DHF2k<F> {
    type Params = DHParamsF2k<F>;
    type PrivateKey = u64;
    type PublicKey = F;
    type SharedSecret = F;

    fn generate_private_key(params: &Self::Params, random_value: u64) -> Self::PrivateKey {
        1 + (random_value % (params.q - 1))
    }

    fn compute_public_key(
        params: &Self::Params,
        private_key: &Self::PrivateKey,
    ) -> Self::PublicKey {
        let sk_bytes = private_key.to_le_bytes();
        params.g.pow(&sk_bytes)
    }

    fn compute_shared_secret(
        _params: &Self::Params,
        our_private_key: &Self::PrivateKey,
        their_public_key: &Self::PublicKey,
    ) -> Self::SharedSecret {
        let sk_bytes = our_private_key.to_le_bytes();
        their_public_key.pow(&sk_bytes)
    }
}

//
// ========================= Extension Field F_p^k DH =========================
//

/// Domain parameters for DH over extension field F_p^k (p ≥ 3)
///
/// # Parameters
/// - `p`: The prime modulus
/// - `k`: The extension degree
/// - `m`: Irreducible polynomial coefficients
/// - `g`: The generator element in F_p^k
/// - `q`: The order of the subgroup generated by g
#[derive(Clone, Debug)]
pub struct DHParamsFpk<F: FieldElement> {
    pub p_description: String, // Description of prime p
    pub k: usize,              // Extension degree
    pub m_description: String, // Description of irreducible polynomial
    pub g: F,                  // Generator
    pub q: u64,                // Order of subgroup
}

impl<F: FieldElement + std::fmt::Debug> DHDomainParameters for DHParamsFpk<F> {
    type Generator = F;

    fn order(&self) -> u64 {
        self.q
    }

    fn generator(&self) -> Self::Generator {
        self.g.clone()
    }
}

/// Diffie-Hellman over extension field F_p^k
pub struct DHFpk<F: FieldElement> {
    _phantom: std::marker::PhantomData<F>,
}

impl<F: FieldElement + std::fmt::Debug> DiffieHellman for DHFpk<F> {
    type Params = DHParamsFpk<F>;
    type PrivateKey = u64;
    type PublicKey = F;
    type SharedSecret = F;

    fn generate_private_key(params: &Self::Params, random_value: u64) -> Self::PrivateKey {
        1 + (random_value % (params.q - 1))
    }

    fn compute_public_key(
        params: &Self::Params,
        private_key: &Self::PrivateKey,
    ) -> Self::PublicKey {
        let sk_bytes = private_key.to_le_bytes();
        params.g.pow(&sk_bytes)
    }

    fn compute_shared_secret(
        _params: &Self::Params,
        our_private_key: &Self::PrivateKey,
        their_public_key: &Self::PublicKey,
    ) -> Self::SharedSecret {
        let sk_bytes = our_private_key.to_le_bytes();
        their_public_key.pow(&sk_bytes)
    }
}

//
// ========================= Elliptic Curve DH =========================
//

/// Domain parameters for Elliptic Curve Diffie-Hellman (ECDH)
///
/// # Parameters
/// - Underlying field F (F_p, F_2^k, or F_p^k)
/// - Curve coefficients a and b
/// - Generator point G
/// - Order q of the subgroup generated by G
#[derive(Clone, Debug)]
pub struct DHParamsEC<F: FieldElement> {
    pub field_description: String, // Description of the underlying field
    pub curve: EllipticCurve<F>,   // The elliptic curve (contains a and b)
    pub generator: Point<F>,       // Generator point G
    pub q: u64,                    // Order of subgroup generated by G
}

impl<F: FieldElement + std::fmt::Debug> DHDomainParameters for DHParamsEC<F> {
    type Generator = Point<F>;

    fn order(&self) -> u64 {
        self.q
    }

    fn generator(&self) -> Self::Generator {
        self.generator.clone()
    }
}

/// Elliptic Curve Diffie-Hellman (ECDH)
pub struct DHEC<F: FieldElement> {
    _phantom: std::marker::PhantomData<F>,
}

impl<F: FieldElement + std::fmt::Debug> DiffieHellman for DHEC<F> {
    type Params = DHParamsEC<F>;
    type PrivateKey = u64;
    type PublicKey = Point<F>;
    type SharedSecret = Point<F>;

    fn generate_private_key(params: &Self::Params, random_value: u64) -> Self::PrivateKey {
        1 + (random_value % (params.q - 1))
    }

    fn compute_public_key(
        params: &Self::Params,
        private_key: &Self::PrivateKey,
    ) -> Self::PublicKey {
        // PK = [sk]G (scalar multiplication)
        let sk_bytes = private_key.to_le_bytes();
        params.curve.scalar_mul(&params.generator, &sk_bytes)
    }

    fn compute_shared_secret(
        params: &Self::Params,
        our_private_key: &Self::PrivateKey,
        their_public_key: &Self::PublicKey,
    ) -> Self::SharedSecret {
        // SS = [sk]EPK (scalar multiplication)
        let sk_bytes = our_private_key.to_le_bytes();
        params.curve.scalar_mul(their_public_key, &sk_bytes)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::bigint::BigInt;
    use crate::field::{BinaryField, ExtensionField, FieldConfig, PrimeField};

    // Test field configurations
    #[derive(Clone, Debug)]
    struct F97;
    static F97_MODULUS: BigInt<4> = BigInt::from_u64(97);
    impl FieldConfig<4> for F97 {
        fn modulus() -> &'static BigInt<4> {
            &F97_MODULUS
        }
        fn irreducible() -> &'static [BigInt<4>] {
            &[]
        }
    }
    type Fp97 = PrimeField<F97, 4>;

    #[derive(Clone, Debug)]
    struct F2_8;
    static F2_MOD: BigInt<4> = BigInt::from_u64(2);
    static F2_8_IRRED: [BigInt<4>; 9] = [
        BigInt::from_u64(1),
        BigInt::from_u64(1),
        BigInt::from_u64(0),
        BigInt::from_u64(1),
        BigInt::from_u64(1),
        BigInt::from_u64(0),
        BigInt::from_u64(0),
        BigInt::from_u64(0),
        BigInt::from_u64(1),
    ];
    impl FieldConfig<4> for F2_8 {
        fn modulus() -> &'static BigInt<4> {
            &F2_MOD
        }
        fn irreducible() -> &'static [BigInt<4>] {
            &F2_8_IRRED
        }
    }
    type F2k8 = BinaryField<F2_8, 4, 8>;

    #[derive(Clone, Debug)]
    struct F5_2;
    static F5_MODULUS: BigInt<4> = BigInt::from_u64(5);
    static F5_2_IRRED: [BigInt<4>; 3] = [
        BigInt::from_u64(2),
        BigInt::from_u64(0),
        BigInt::from_u64(1),
    ];
    impl FieldConfig<4> for F5_2 {
        fn modulus() -> &'static BigInt<4> {
            &F5_MODULUS
        }
        fn irreducible() -> &'static [BigInt<4>] {
            &F5_2_IRRED
        }
    }
    type F52 = ExtensionField<F5_2, 4, 2>;

    #[test]
    fn test_dh_prime_field() {
        // Setup DH parameters for F_97
        let params = DHParamsFp {
            p_description: "97".to_string(),
            g: Fp97::from_u64(5),
            q: 48,
        };

        // Alice generates keys
        let alice_sk = DHFp::<Fp97>::generate_private_key(&params, 12345);
        let alice_pk = DHFp::<Fp97>::compute_public_key(&params, &alice_sk);

        // Bob generates keys
        let bob_sk = DHFp::<Fp97>::generate_private_key(&params, 67890);
        let bob_pk = DHFp::<Fp97>::compute_public_key(&params, &bob_sk);

        // Both compute shared secret
        let alice_shared = DHFp::<Fp97>::compute_shared_secret(&params, &alice_sk, &bob_pk);
        let bob_shared = DHFp::<Fp97>::compute_shared_secret(&params, &bob_sk, &alice_pk);

        // They should match
        assert_eq!(alice_shared, bob_shared);
        assert!(!alice_shared.is_zero());
    }

    #[test]
    fn test_dh_binary_field() {
        // Setup DH parameters for F_2^8
        let params = DHParamsF2k {
            k: 8,
            m_description: "x^8 + x^4 + x^3 + x + 1".to_string(),
            g: F2k8::from_u64(0x03),
            q: 255,
        };

        // Alice generates keys
        let alice_sk = DHF2k::<F2k8>::generate_private_key(&params, 111);
        let alice_pk = DHF2k::<F2k8>::compute_public_key(&params, &alice_sk);

        // Bob generates keys
        let bob_sk = DHF2k::<F2k8>::generate_private_key(&params, 222);
        let bob_pk = DHF2k::<F2k8>::compute_public_key(&params, &bob_sk);

        // Both compute shared secret
        let alice_shared = DHF2k::<F2k8>::compute_shared_secret(&params, &alice_sk, &bob_pk);
        let bob_shared = DHF2k::<F2k8>::compute_shared_secret(&params, &bob_sk, &alice_pk);

        // They should match
        assert_eq!(alice_shared, bob_shared);
        assert!(!alice_shared.is_zero());
    }

    #[test]
    fn test_dh_extension_field() {
        // Setup DH parameters for F_5^2
        let g_coeffs = [BigInt::from_u64(0), BigInt::from_u64(1)];
        let params = DHParamsFpk {
            p_description: "5".to_string(),
            k: 2,
            m_description: "x^2 + 2".to_string(),
            g: F52::from_coeffs(g_coeffs),
            q: 24,
        };

        // Alice generates keys
        let alice_sk = DHFpk::<F52>::generate_private_key(&params, 333);
        let alice_pk = DHFpk::<F52>::compute_public_key(&params, &alice_sk);

        // Bob generates keys
        let bob_sk = DHFpk::<F52>::generate_private_key(&params, 444);
        let bob_pk = DHFpk::<F52>::compute_public_key(&params, &bob_sk);

        // Both compute shared secret
        let alice_shared = DHFpk::<F52>::compute_shared_secret(&params, &alice_sk, &bob_pk);
        let bob_shared = DHFpk::<F52>::compute_shared_secret(&params, &bob_sk, &alice_pk);

        // They should match
        assert_eq!(alice_shared, bob_shared);
        assert!(!alice_shared.is_zero());
    }

    #[test]
    fn test_ecdh_prime_field() {
        // Setup ECDH parameters over F_97
        let a = Fp97::from_u64(2);
        let b = Fp97::from_u64(3);
        let curve = EllipticCurve::new(a, b);
        let gx = Fp97::from_u64(17);
        let gy = Fp97::from_u64(26);
        let generator = Point::Affine { x: gx, y: gy };

        let params = DHParamsEC {
            field_description: "F_97".to_string(),
            curve,
            generator,
            q: 17,
        };

        // Alice generates keys with same small private keys for demonstration
        let alice_sk = 3; // Use small fixed values instead of random
        let alice_pk = DHEC::<Fp97>::compute_public_key(&params, &alice_sk);

        // Bob generates keys
        let bob_sk = 3; // Same value to verify scalar multiplication works
        let bob_pk = DHEC::<Fp97>::compute_public_key(&params, &bob_sk);

        // With same private key, public keys should match
        assert_eq!(alice_pk, bob_pk);
        assert_ne!(alice_pk, Point::Infinity);

        // Note: Full ECDH test requires knowing the actual order of the generator point
        // For production, use validated curve parameters with known orders
    }

    #[test]
    fn test_ecdh_scalar_multiplication_works() {
        // Verify that scalar multiplication produces consistent results
        let a = Fp97::from_u64(2);
        let b = Fp97::from_u64(3);
        let curve = EllipticCurve::new(a, b);
        let gx = Fp97::from_u64(17);
        let gy = Fp97::from_u64(26);
        let generator = Point::Affine { x: gx, y: gy };

        let params = DHParamsEC {
            field_description: "F_97".to_string(),
            curve,
            generator,
            q: 100, // Large enough for test
        };

        // Test that [2]G gives same result whether computed as 2*G or G+G
        let sk = 2;
        let result = DHEC::<Fp97>::compute_public_key(&params, &sk);

        assert_ne!(result, Point::Infinity);
        assert_ne!(result, params.generator);
    }

    #[test]
    fn test_dh_private_key_generation() {
        let params = DHParamsFp {
            p_description: "97".to_string(),
            g: Fp97::from_u64(5),
            q: 48,
        };

        // Generate multiple private keys with different random values
        let sk1 = DHFp::<Fp97>::generate_private_key(&params, 100);
        let sk2 = DHFp::<Fp97>::generate_private_key(&params, 200);
        let sk3 = DHFp::<Fp97>::generate_private_key(&params, 300);

        // All should be in range [1, q-1]
        assert!(sk1 >= 1 && sk1 < params.q);
        assert!(sk2 >= 1 && sk2 < params.q);
        assert!(sk3 >= 1 && sk3 < params.q);

        // Different random values should produce different keys (modulo q)
        assert_ne!(sk1, sk2);
    }

    #[test]
    fn test_dh_public_keys_differ() {
        let params = DHParamsFp {
            p_description: "97".to_string(),
            g: Fp97::from_u64(5),
            q: 48,
        };

        let sk1 = DHFp::<Fp97>::generate_private_key(&params, 111);
        let sk2 = DHFp::<Fp97>::generate_private_key(&params, 222);

        let pk1 = DHFp::<Fp97>::compute_public_key(&params, &sk1);
        let pk2 = DHFp::<Fp97>::compute_public_key(&params, &sk2);

        // Different private keys should produce different public keys
        assert_ne!(pk1, pk2);
    }

    #[test]
    fn test_dh_commutativity() {
        // Test that (g^a)^b == (g^b)^a
        let params = DHParamsFp {
            p_description: "97".to_string(),
            g: Fp97::from_u64(5),
            q: 48,
        };

        let a = DHFp::<Fp97>::generate_private_key(&params, 555);
        let b = DHFp::<Fp97>::generate_private_key(&params, 777);

        let g_a = DHFp::<Fp97>::compute_public_key(&params, &a);
        let g_b = DHFp::<Fp97>::compute_public_key(&params, &b);

        let shared1 = DHFp::<Fp97>::compute_shared_secret(&params, &a, &g_b);
        let shared2 = DHFp::<Fp97>::compute_shared_secret(&params, &b, &g_a);

        assert_eq!(shared1, shared2);
    }
}
