//! Diffie-Hellman Key Exchange Protocol
//!
//! This module implements the Diffie-Hellman (DH) key exchange protocol for various
//! algebraic structures:
//! 1. Classic prime field F_p
//! 2. Binary extension field F_2^k
//! 3. Extended prime field F_p^k (p ≥ 3)
//! 4. Elliptic curves over F_p, F_2^k, and F_p^k
//!
//! # Protocol Overview
//!
//! Diffie-Hellman allows two parties to establish a shared secret over an insecure channel:
//!
//! ## Phase 1: Key Generation
//! Each party generates:
//! - **Private key (sk)**: Random integer from Z_q
//! - **Public key (pk)**: Computed as g^sk (or [sk]G for elliptic curves)
//!
//! ## Phase 2: Key Agreement
//! Each party computes the shared secret:
//! - **Shared secret (ss)**: Computed as epk^sk where epk is the other party's public key
//!
//! # Security Considerations
//!
//! - The order q of the generator g (or G) should be prime for security
//! - For DDH-security, g should generate a subgroup of order q, not the full group
//! - Private keys must be randomly generated from a cryptographically secure source
//! - Implementations should use constant-time operations to prevent timing attacks
//!
//! # Scalar Size
//!
//! This implementation uses `BigInt<N>` for private keys and group orders, supporting
//! arbitrary precision scalars. For cryptographic security, q should be at least
//! 160 bits (NIST recommends 256+ bits for ECDH).

use crate::bigint::BigInt;
use crate::elliptic_curve::{EllipticCurve, Point};
use crate::field_trait::FieldElement;
use std::fmt::Debug;

/// Domain parameters for Diffie-Hellman key exchange
///
/// This trait defines the common interface for all DH parameter types.
/// Different algebraic structures have different parameter representations.
///
/// The const generic `N` specifies the number of 64-bit limbs for BigInt scalars.
pub trait DHDomainParameters<const N: usize>: Clone + Debug {
    /// The type of the generator element
    type Generator: Clone + Debug;

    /// The order of the group generated by g (should be prime)
    fn order(&self) -> &BigInt<N>;

    /// The generator element
    fn generator(&self) -> Self::Generator;
}

/// Diffie-Hellman protocol implementation
///
/// This trait defines the DH protocol operations for a specific algebraic structure.
///
/// The const generic `N` specifies the number of 64-bit limbs for BigInt scalars.
pub trait DiffieHellman<const N: usize> {
    /// Domain parameters type
    type Params: DHDomainParameters<N>;

    /// Private key type (BigInt modulo q)
    type PrivateKey: Clone + Debug;

    /// Public key type (depends on the algebraic structure)
    type PublicKey: Clone + Debug + PartialEq;

    /// Shared secret type (same as public key type)
    type SharedSecret: Clone + Debug + PartialEq;

    /// Generates a new private key
    ///
    /// # Arguments
    /// * `params` - The domain parameters
    /// * `random_value` - A random BigInt (in real applications, use cryptographically secure RNG)
    ///
    /// # Returns
    /// A new private key in range [1, q-1]
    fn generate_private_key(params: &Self::Params, random_value: &BigInt<N>) -> Self::PrivateKey;

    /// Computes the public key from a private key
    ///
    /// # Arguments
    /// * `params` - The domain parameters
    /// * `private_key` - The private key
    ///
    /// # Returns
    /// The corresponding public key (g^sk or [sk]G)
    fn compute_public_key(params: &Self::Params, private_key: &Self::PrivateKey)
    -> Self::PublicKey;

    /// Computes the shared secret from our private key and the other party's public key
    ///
    /// # Arguments
    /// * `params` - The domain parameters
    /// * `our_private_key` - Our private key
    /// * `their_public_key` - The other party's public key
    ///
    /// # Returns
    /// The shared secret (epk^sk or [sk]EPK)
    fn compute_shared_secret(
        params: &Self::Params,
        our_private_key: &Self::PrivateKey,
        their_public_key: &Self::PublicKey,
    ) -> Self::SharedSecret;
}

//
// ========================= Prime Field F_p DH =========================
//

/// Domain parameters for DH over prime field F_p
///
/// # Parameters
/// - `p`: The prime modulus
/// - `g`: The generator element in F_p
/// - `q`: The order of the subgroup generated by g (should be prime)
///
/// # Type Parameters
/// - `F`: The field element type
/// - `N`: Number of 64-bit limbs for BigInt scalars
#[derive(Clone, Debug)]
pub struct DHParamsFp<F: FieldElement, const N: usize> {
    pub p_description: String, // Description of the prime (e.g., "97")
    pub g: F,                  // Generator
    pub q: BigInt<N>,          // Order of subgroup generated by g
}

impl<F: FieldElement + std::fmt::Debug, const N: usize> DHDomainParameters<N> for DHParamsFp<F, N> {
    type Generator = F;

    fn order(&self) -> &BigInt<N> {
        &self.q
    }

    fn generator(&self) -> Self::Generator {
        self.g.clone()
    }
}

/// Diffie-Hellman over prime field F_p
pub struct DHFp<F: FieldElement, const N: usize> {
    _phantom: std::marker::PhantomData<F>,
}

impl<F: FieldElement + std::fmt::Debug, const N: usize> DiffieHellman<N> for DHFp<F, N> {
    type Params = DHParamsFp<F, N>;
    type PrivateKey = BigInt<N>;
    type PublicKey = F;
    type SharedSecret = F;

    fn generate_private_key(params: &Self::Params, random_value: &BigInt<N>) -> Self::PrivateKey {
        // Private key should be in [1, q-1]
        // sk = 1 + (random_value mod (q - 1))
        let one = BigInt::<N>::one();
        let q_minus_1 = params.q.sub_with_borrow(&one).0;
        let remainder = random_value.modulo(&q_minus_1);
        remainder.mod_add(&one, &params.q)
    }

    fn compute_public_key(
        params: &Self::Params,
        private_key: &Self::PrivateKey,
    ) -> Self::PublicKey {
        // pk = g^sk mod p
        let sk_bytes = private_key.to_le_bytes_vec();
        params.g.pow(&sk_bytes)
    }

    fn compute_shared_secret(
        _params: &Self::Params,
        our_private_key: &Self::PrivateKey,
        their_public_key: &Self::PublicKey,
    ) -> Self::SharedSecret {
        // ss = epk^sk mod p
        let sk_bytes = our_private_key.to_le_bytes_vec();
        their_public_key.pow(&sk_bytes)
    }
}

//
// ========================= Binary Field F_2^k DH =========================
//

/// Domain parameters for DH over binary field F_2^k
///
/// # Parameters
/// - `m`: Coefficients of the irreducible polynomial (bit string)
/// - `g`: The generator element in F_2^k
/// - `q`: The order of the subgroup generated by g
///
/// # Type Parameters
/// - `F`: The field element type
/// - `N`: Number of 64-bit limbs for BigInt scalars
#[derive(Clone, Debug)]
pub struct DHParamsF2k<F: FieldElement, const N: usize> {
    pub k: usize,              // Extension degree
    pub m_description: String, // Description of irreducible polynomial
    pub g: F,                  // Generator
    pub q: BigInt<N>,          // Order of subgroup
}

impl<F: FieldElement + std::fmt::Debug, const N: usize> DHDomainParameters<N> for DHParamsF2k<F, N> {
    type Generator = F;

    fn order(&self) -> &BigInt<N> {
        &self.q
    }

    fn generator(&self) -> Self::Generator {
        self.g.clone()
    }
}

/// Diffie-Hellman over binary field F_2^k
pub struct DHF2k<F: FieldElement, const N: usize> {
    _phantom: std::marker::PhantomData<F>,
}

impl<F: FieldElement + std::fmt::Debug, const N: usize> DiffieHellman<N> for DHF2k<F, N> {
    type Params = DHParamsF2k<F, N>;
    type PrivateKey = BigInt<N>;
    type PublicKey = F;
    type SharedSecret = F;

    fn generate_private_key(params: &Self::Params, random_value: &BigInt<N>) -> Self::PrivateKey {
        let one = BigInt::<N>::one();
        let q_minus_1 = params.q.sub_with_borrow(&one).0;
        let remainder = random_value.modulo(&q_minus_1);
        remainder.mod_add(&one, &params.q)
    }

    fn compute_public_key(
        params: &Self::Params,
        private_key: &Self::PrivateKey,
    ) -> Self::PublicKey {
        let sk_bytes = private_key.to_le_bytes_vec();
        params.g.pow(&sk_bytes)
    }

    fn compute_shared_secret(
        _params: &Self::Params,
        our_private_key: &Self::PrivateKey,
        their_public_key: &Self::PublicKey,
    ) -> Self::SharedSecret {
        let sk_bytes = our_private_key.to_le_bytes_vec();
        their_public_key.pow(&sk_bytes)
    }
}

//
// ========================= Extension Field F_p^k DH =========================
//

/// Domain parameters for DH over extension field F_p^k (p ≥ 3)
///
/// # Parameters
/// - `p`: The prime modulus
/// - `k`: The extension degree
/// - `m`: Irreducible polynomial coefficients
/// - `g`: The generator element in F_p^k
/// - `q`: The order of the subgroup generated by g
///
/// # Type Parameters
/// - `F`: The field element type
/// - `N`: Number of 64-bit limbs for BigInt scalars
#[derive(Clone, Debug)]
pub struct DHParamsFpk<F: FieldElement, const N: usize> {
    pub p_description: String, // Description of prime p
    pub k: usize,              // Extension degree
    pub m_description: String, // Description of irreducible polynomial
    pub g: F,                  // Generator
    pub q: BigInt<N>,          // Order of subgroup
}

impl<F: FieldElement + std::fmt::Debug, const N: usize> DHDomainParameters<N> for DHParamsFpk<F, N> {
    type Generator = F;

    fn order(&self) -> &BigInt<N> {
        &self.q
    }

    fn generator(&self) -> Self::Generator {
        self.g.clone()
    }
}

/// Diffie-Hellman over extension field F_p^k
pub struct DHFpk<F: FieldElement, const N: usize> {
    _phantom: std::marker::PhantomData<F>,
}

impl<F: FieldElement + std::fmt::Debug, const N: usize> DiffieHellman<N> for DHFpk<F, N> {
    type Params = DHParamsFpk<F, N>;
    type PrivateKey = BigInt<N>;
    type PublicKey = F;
    type SharedSecret = F;

    fn generate_private_key(params: &Self::Params, random_value: &BigInt<N>) -> Self::PrivateKey {
        let one = BigInt::<N>::one();
        let q_minus_1 = params.q.sub_with_borrow(&one).0;
        let remainder = random_value.modulo(&q_minus_1);
        remainder.mod_add(&one, &params.q)
    }

    fn compute_public_key(
        params: &Self::Params,
        private_key: &Self::PrivateKey,
    ) -> Self::PublicKey {
        let sk_bytes = private_key.to_le_bytes_vec();
        params.g.pow(&sk_bytes)
    }

    fn compute_shared_secret(
        _params: &Self::Params,
        our_private_key: &Self::PrivateKey,
        their_public_key: &Self::PublicKey,
    ) -> Self::SharedSecret {
        let sk_bytes = our_private_key.to_le_bytes_vec();
        their_public_key.pow(&sk_bytes)
    }
}

//
// ========================= Elliptic Curve DH =========================
//

/// Domain parameters for Elliptic Curve Diffie-Hellman (ECDH)
///
/// # Parameters
/// - Underlying field F (F_p, F_2^k, or F_p^k)
/// - Curve coefficients a and b
/// - Generator point G
/// - Order q of the subgroup generated by G
///
/// # Type Parameters
/// - `F`: The field element type
/// - `N`: Number of 64-bit limbs for BigInt scalars
#[derive(Clone, Debug)]
pub struct DHParamsEC<F: FieldElement, const N: usize> {
    pub field_description: String, // Description of the underlying field
    pub curve: EllipticCurve<F>,   // The elliptic curve (contains a and b)
    pub generator: Point<F>,       // Generator point G
    pub q: BigInt<N>,              // Order of subgroup generated by G
}

impl<F: FieldElement + std::fmt::Debug, const N: usize> DHDomainParameters<N> for DHParamsEC<F, N> {
    type Generator = Point<F>;

    fn order(&self) -> &BigInt<N> {
        &self.q
    }

    fn generator(&self) -> Self::Generator {
        self.generator.clone()
    }
}

/// Elliptic Curve Diffie-Hellman (ECDH)
///
/// # Public Key Validation
///
/// For secure ECDH, received public keys should be validated:
/// 1. Point is not infinity
/// 2. Point coordinates are valid field elements
/// 3. Point is on the curve (satisfies curve equation)
/// 4. (Optional) Point is in the correct subgroup when cofactor > 1
///
/// Use [`validate_ec_public_key`] to perform these checks.
pub struct DHEC<F: FieldElement, const N: usize> {
    _phantom: std::marker::PhantomData<F>,
}

/// Validation errors for ECDH public keys
#[derive(Debug, Clone, PartialEq)]
pub enum ECDHValidationError {
    /// Public key is point at infinity
    PointAtInfinity,
    /// Public key is not on the curve
    NotOnCurve,
}

/// Validate an ECDH public key
///
/// Checks:
/// - Point is not infinity
/// - Point is on the curve
///
/// # Returns
/// `Ok(())` if valid, `Err(ECDHValidationError)` otherwise
pub fn validate_ec_public_key<F: FieldElement, const N: usize>(
    params: &DHParamsEC<F, N>,
    public_key: &Point<F>,
) -> Result<(), ECDHValidationError> {
    // Check point is not infinity
    if matches!(public_key, Point::Infinity) {
        return Err(ECDHValidationError::PointAtInfinity);
    }

    // Check point is on curve
    if !params.curve.is_on_curve(public_key) {
        return Err(ECDHValidationError::NotOnCurve);
    }

    Ok(())
}

impl<F: FieldElement + std::fmt::Debug, const N: usize> DiffieHellman<N> for DHEC<F, N> {
    type Params = DHParamsEC<F, N>;
    type PrivateKey = BigInt<N>;
    type PublicKey = Point<F>;
    type SharedSecret = Point<F>;

    fn generate_private_key(params: &Self::Params, random_value: &BigInt<N>) -> Self::PrivateKey {
        let one = BigInt::<N>::one();
        let q_minus_1 = params.q.sub_with_borrow(&one).0;
        let remainder = random_value.modulo(&q_minus_1);
        remainder.mod_add(&one, &params.q)
    }

    fn compute_public_key(
        params: &Self::Params,
        private_key: &Self::PrivateKey,
    ) -> Self::PublicKey {
        // PK = [sk]G (scalar multiplication)
        let sk_bytes = private_key.to_le_bytes_vec();
        params.curve.scalar_mul(&params.generator, &sk_bytes)
    }

    fn compute_shared_secret(
        params: &Self::Params,
        our_private_key: &Self::PrivateKey,
        their_public_key: &Self::PublicKey,
    ) -> Self::SharedSecret {
        // SS = [sk]EPK (scalar multiplication)
        let sk_bytes = our_private_key.to_le_bytes_vec();
        params.curve.scalar_mul(their_public_key, &sk_bytes)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::bigint::BigInt;
    use crate::field::{BinaryField, ExtensionField, FieldConfig, PrimeField};

    // Test field configurations
    #[derive(Clone, Debug)]
    struct F97;
    static F97_MODULUS: BigInt<4> = BigInt::from_u64(97);
    impl FieldConfig<4> for F97 {
        fn modulus() -> &'static BigInt<4> {
            &F97_MODULUS
        }
        fn irreducible() -> &'static [BigInt<4>] {
            &[]
        }
    }
    type Fp97 = PrimeField<F97, 4>;

    #[derive(Clone, Debug)]
    struct F2_8;
    static F2_MOD: BigInt<4> = BigInt::from_u64(2);
    static F2_8_IRRED: [BigInt<4>; 9] = [
        BigInt::from_u64(1),
        BigInt::from_u64(1),
        BigInt::from_u64(0),
        BigInt::from_u64(1),
        BigInt::from_u64(1),
        BigInt::from_u64(0),
        BigInt::from_u64(0),
        BigInt::from_u64(0),
        BigInt::from_u64(1),
    ];
    impl FieldConfig<4> for F2_8 {
        fn modulus() -> &'static BigInt<4> {
            &F2_MOD
        }
        fn irreducible() -> &'static [BigInt<4>] {
            &F2_8_IRRED
        }
    }
    type F2k8 = BinaryField<F2_8, 4, 8>;

    #[derive(Clone, Debug)]
    struct F5_2;
    static F5_MODULUS: BigInt<4> = BigInt::from_u64(5);
    static F5_2_IRRED: [BigInt<4>; 3] = [
        BigInt::from_u64(2),
        BigInt::from_u64(0),
        BigInt::from_u64(1),
    ];
    impl FieldConfig<4> for F5_2 {
        fn modulus() -> &'static BigInt<4> {
            &F5_MODULUS
        }
        fn irreducible() -> &'static [BigInt<4>] {
            &F5_2_IRRED
        }
    }
    type F52 = ExtensionField<F5_2, 4, 2>;

    #[test]
    fn test_dh_prime_field() {
        // Setup DH parameters for F_97
        let params = DHParamsFp {
            p_description: "97".to_string(),
            g: Fp97::from_u64(5),
            q: BigInt::from_u64(48),
        };

        // Alice generates keys
        let alice_sk = DHFp::<Fp97, 4>::generate_private_key(&params, &BigInt::from_u64(12345));
        let alice_pk = DHFp::<Fp97, 4>::compute_public_key(&params, &alice_sk);

        // Bob generates keys
        let bob_sk = DHFp::<Fp97, 4>::generate_private_key(&params, &BigInt::from_u64(67890));
        let bob_pk = DHFp::<Fp97, 4>::compute_public_key(&params, &bob_sk);

        // Both compute shared secret
        let alice_shared = DHFp::<Fp97, 4>::compute_shared_secret(&params, &alice_sk, &bob_pk);
        let bob_shared = DHFp::<Fp97, 4>::compute_shared_secret(&params, &bob_sk, &alice_pk);

        // They should match
        assert_eq!(alice_shared, bob_shared);
        assert!(!alice_shared.is_zero());
    }

    #[test]
    fn test_dh_binary_field() {
        // Setup DH parameters for F_2^8
        // NOTE: q=255 is the full multiplicative group order |F_{2^8}^*| = 2^8 - 1.
        // This is fine for correctness testing, but NOT DDH-secure:
        // DDH requires a prime-order subgroup. For production, factor 255 = 3·5·17
        // and pick a generator of prime order (e.g., order 17).
        let params = DHParamsF2k {
            k: 8,
            m_description: "x^8 + x^4 + x^3 + x + 1".to_string(),
            g: F2k8::from_u64(0x03),
            q: BigInt::from_u64(255),
        };

        // Alice generates keys
        let alice_sk = DHF2k::<F2k8, 4>::generate_private_key(&params, &BigInt::from_u64(111));
        let alice_pk = DHF2k::<F2k8, 4>::compute_public_key(&params, &alice_sk);

        // Bob generates keys
        let bob_sk = DHF2k::<F2k8, 4>::generate_private_key(&params, &BigInt::from_u64(222));
        let bob_pk = DHF2k::<F2k8, 4>::compute_public_key(&params, &bob_sk);

        // Both compute shared secret
        let alice_shared = DHF2k::<F2k8, 4>::compute_shared_secret(&params, &alice_sk, &bob_pk);
        let bob_shared = DHF2k::<F2k8, 4>::compute_shared_secret(&params, &bob_sk, &alice_pk);

        // They should match
        assert_eq!(alice_shared, bob_shared);
        assert!(!alice_shared.is_zero());
    }

    #[test]
    fn test_dh_extension_field() {
        // Setup DH parameters for F_5^2
        // |F_{5^2}^*| = 24 = 2^3 · 3. For DDH security, g should generate a
        // prime-order subgroup (order 2 or 3). Here we use full order for testing.
        let g_coeffs = [BigInt::from_u64(0), BigInt::from_u64(1)];
        let params = DHParamsFpk {
            p_description: "5".to_string(),
            k: 2,
            m_description: "x^2 + 2".to_string(),
            g: F52::from_coeffs(g_coeffs),
            q: BigInt::from_u64(24),
        };

        // Alice generates keys
        let alice_sk = DHFpk::<F52, 4>::generate_private_key(&params, &BigInt::from_u64(333));
        let alice_pk = DHFpk::<F52, 4>::compute_public_key(&params, &alice_sk);

        // Bob generates keys
        let bob_sk = DHFpk::<F52, 4>::generate_private_key(&params, &BigInt::from_u64(444));
        let bob_pk = DHFpk::<F52, 4>::compute_public_key(&params, &bob_sk);

        // Both compute shared secret
        let alice_shared = DHFpk::<F52, 4>::compute_shared_secret(&params, &alice_sk, &bob_pk);
        let bob_shared = DHFpk::<F52, 4>::compute_shared_secret(&params, &bob_sk, &alice_pk);

        // They should match
        assert_eq!(alice_shared, bob_shared);
        assert!(!alice_shared.is_zero());
    }

    #[test]
    fn test_ecdh_prime_field() {
        // Setup ECDH parameters over F_97
        let a = Fp97::from_u64(2);
        let b = Fp97::from_u64(3);
        let curve = EllipticCurve::new(a, b);
        let gx = Fp97::from_u64(17);
        let gy = Fp97::from_u64(26);
        let generator = Point::Affine { x: gx, y: gy };

        let params = DHParamsEC {
            field_description: "F_97".to_string(),
            curve,
            generator,
            q: BigInt::from_u64(17),
        };

        // Alice generates keys with same small private keys for demonstration
        let alice_sk = BigInt::from_u64(3);
        let alice_pk = DHEC::<Fp97, 4>::compute_public_key(&params, &alice_sk);

        // Bob generates keys
        let bob_sk = BigInt::from_u64(3); // Same value to verify scalar multiplication works
        let bob_pk = DHEC::<Fp97, 4>::compute_public_key(&params, &bob_sk);

        // With same private key, public keys should match
        assert_eq!(alice_pk, bob_pk);
        assert_ne!(alice_pk, Point::Infinity);
    }

    #[test]
    fn test_ecdh_scalar_multiplication_works() {
        // Verify that scalar multiplication produces consistent results
        let a = Fp97::from_u64(2);
        let b = Fp97::from_u64(3);
        let curve = EllipticCurve::new(a, b);
        let gx = Fp97::from_u64(17);
        let gy = Fp97::from_u64(26);
        let generator = Point::Affine { x: gx, y: gy };

        let params = DHParamsEC {
            field_description: "F_97".to_string(),
            curve,
            generator,
            q: BigInt::from_u64(100), // Large enough for test
        };

        // Test that [2]G gives same result whether computed as 2*G or G+G
        let sk = BigInt::from_u64(2);
        let result = DHEC::<Fp97, 4>::compute_public_key(&params, &sk);

        assert_ne!(result, Point::Infinity);
        assert_ne!(result, params.generator);
    }

    #[test]
    fn test_ecdh_agreement_fp97() {
        // Curve: y^2 = x^3 + 2x + 3 over F_97
        let a = Fp97::from_u64(2);
        let b = Fp97::from_u64(3);
        let curve = EllipticCurve::new(a, b);

        // Use a known on-curve point as generator (already used in your EC tests)
        let g = Point::Affine {
            x: Fp97::from_u64(3),
            y: Fp97::from_u64(6),
        };
        assert!(curve.is_on_curve(&g));

        let params = DHParamsEC {
            field_description: "F_97".to_string(),
            curve: curve.clone(),
            generator: g.clone(),
            q: BigInt::from_u64(97), // not used in compute_* if you pass fixed sks; ok for test
        };

        // Use distinct scalars
        let alice_sk = BigInt::from_u64(7);
        let bob_sk = BigInt::from_u64(11);

        let alice_pk = DHEC::<Fp97, 4>::compute_public_key(&params, &alice_sk);
        let bob_pk = DHEC::<Fp97, 4>::compute_public_key(&params, &bob_sk);

        // Shared secrets
        let alice_ss = DHEC::<Fp97, 4>::compute_shared_secret(&params, &alice_sk, &bob_pk);
        let bob_ss = DHEC::<Fp97, 4>::compute_shared_secret(&params, &bob_sk, &alice_pk);

        // Core ECDH property
        assert_eq!(alice_ss, bob_ss);

        // Sanity: shared secret should be a valid curve point and typically not infinity
        assert!(params.curve.is_on_curve(&alice_ss));
        assert_ne!(alice_ss, Point::Infinity);

        // Also ensure pk are valid and distinct
        assert!(params.curve.is_on_curve(&alice_pk));
        assert!(params.curve.is_on_curve(&bob_pk));
        assert_ne!(alice_pk, bob_pk);
    }

    #[test]
    fn test_ecdh_public_key_validation() {
        // Setup curve: y^2 = x^3 + 2x + 3 over F_97
        let a = Fp97::from_u64(2);
        let b = Fp97::from_u64(3);
        let curve = EllipticCurve::new(a, b);

        let g = Point::Affine {
            x: Fp97::from_u64(3),
            y: Fp97::from_u64(6),
        };

        let params = DHParamsEC {
            field_description: "F_97".to_string(),
            curve: curve.clone(),
            generator: g.clone(),
            q: BigInt::from_u64(100),
        };

        // Valid point should pass validation
        let valid_pk = DHEC::<Fp97, 4>::compute_public_key(&params, &BigInt::from_u64(7));
        assert!(validate_ec_public_key(&params, &valid_pk).is_ok());

        // Infinity should be rejected
        let infinity = Point::Infinity;
        assert_eq!(
            validate_ec_public_key(&params, &infinity),
            Err(ECDHValidationError::PointAtInfinity)
        );

        // Point not on curve should be rejected
        // (3, 7) is NOT on y^2 = x^3 + 2x + 3 mod 97: 7^2=49, 3^3+2*3+3=36 (mod 97)
        let off_curve = Point::Affine {
            x: Fp97::from_u64(3),
            y: Fp97::from_u64(7),
        };
        assert_eq!(
            validate_ec_public_key(&params, &off_curve),
            Err(ECDHValidationError::NotOnCurve)
        );
    }

    #[test]
    fn test_dh_private_key_generation() {
        let params = DHParamsFp {
            p_description: "97".to_string(),
            g: Fp97::from_u64(5),
            q: BigInt::from_u64(48),
        };

        // Generate multiple private keys with different random values
        let sk1 = DHFp::<Fp97, 4>::generate_private_key(&params, &BigInt::from_u64(100));
        let sk2 = DHFp::<Fp97, 4>::generate_private_key(&params, &BigInt::from_u64(200));
        let sk3 = DHFp::<Fp97, 4>::generate_private_key(&params, &BigInt::from_u64(300));

        // All should be in range [1, q-1]
        let one = BigInt::<4>::one();
        assert!(sk1.compare(&one) != std::cmp::Ordering::Less && sk1.compare(&params.q) == std::cmp::Ordering::Less);
        assert!(sk2.compare(&one) != std::cmp::Ordering::Less && sk2.compare(&params.q) == std::cmp::Ordering::Less);
        assert!(sk3.compare(&one) != std::cmp::Ordering::Less && sk3.compare(&params.q) == std::cmp::Ordering::Less);

        // Different random values should produce different keys (modulo q)
        assert_ne!(sk1, sk2);
    }

    #[test]
    fn test_dh_public_keys_differ() {
        let params = DHParamsFp {
            p_description: "97".to_string(),
            g: Fp97::from_u64(5),
            q: BigInt::from_u64(48),
        };

        let sk1 = DHFp::<Fp97, 4>::generate_private_key(&params, &BigInt::from_u64(111));
        let sk2 = DHFp::<Fp97, 4>::generate_private_key(&params, &BigInt::from_u64(222));

        let pk1 = DHFp::<Fp97, 4>::compute_public_key(&params, &sk1);
        let pk2 = DHFp::<Fp97, 4>::compute_public_key(&params, &sk2);

        // Different private keys should produce different public keys
        assert_ne!(pk1, pk2);
    }

    #[test]
    fn test_dh_commutativity() {
        // Test that (g^a)^b == (g^b)^a
        let params = DHParamsFp {
            p_description: "97".to_string(),
            g: Fp97::from_u64(5),
            q: BigInt::from_u64(48),
        };

        let a = DHFp::<Fp97, 4>::generate_private_key(&params, &BigInt::from_u64(555));
        let b = DHFp::<Fp97, 4>::generate_private_key(&params, &BigInt::from_u64(777));

        let g_a = DHFp::<Fp97, 4>::compute_public_key(&params, &a);
        let g_b = DHFp::<Fp97, 4>::compute_public_key(&params, &b);

        let shared1 = DHFp::<Fp97, 4>::compute_shared_secret(&params, &a, &g_b);
        let shared2 = DHFp::<Fp97, 4>::compute_shared_secret(&params, &b, &g_a);

        assert_eq!(shared1, shared2);
    }

    #[test]
    fn dh_fp97_known_vector() {
        // p=97, g=5
        let params = DHParamsFp {
            p_description: "97".to_string(),
            g: Fp97::from_u64(5),
            q: BigInt::from_u64(48),
        };

        let a = BigInt::from_u64(15);
        let b = BigInt::from_u64(27);

        let a_pub = DHFp::<Fp97, 4>::compute_public_key(&params, &a);
        let b_pub = DHFp::<Fp97, 4>::compute_public_key(&params, &b);

        // Expected from math:
        assert_eq!(a_pub, Fp97::from_u64(46));
        assert_eq!(b_pub, Fp97::from_u64(34));

        let s1 = DHFp::<Fp97, 4>::compute_shared_secret(&params, &a, &b_pub);
        let s2 = DHFp::<Fp97, 4>::compute_shared_secret(&params, &b, &a_pub);

        assert_eq!(s1, s2);
        assert_eq!(s1, Fp97::from_u64(77));
    }

    #[test]
    fn dh_gf256_known_vector() {
        // NOTE: q=255 is full group order, not DDH-secure (see test_dh_binary_field).
        let params = DHParamsF2k {
            k: 8,
            m_description: "x^8 + x^4 + x^3 + x + 1".to_string(),
            g: F2k8::from_u64(0x03),
            q: BigInt::from_u64(255),
        };

        let a = BigInt::from_u64(112);
        let b = BigInt::from_u64(223);

        let a_pub = DHF2k::<F2k8, 4>::compute_public_key(&params, &a);
        let b_pub = DHF2k::<F2k8, 4>::compute_public_key(&params, &b);

        assert_eq!(a_pub, F2k8::from_u64(0xFE));
        assert_eq!(b_pub, F2k8::from_u64(0x0E));

        let s1 = DHF2k::<F2k8, 4>::compute_shared_secret(&params, &a, &b_pub);
        let s2 = DHF2k::<F2k8, 4>::compute_shared_secret(&params, &b, &a_pub);

        assert_eq!(s1, s2);
        assert_eq!(s1, F2k8::from_u64(0x4B));
    }

    #[test]
    fn dh_f5_2_known_vector() {
        let g_coeffs = [BigInt::from_u64(1), BigInt::from_u64(1)];
        let params = DHParamsFpk {
            p_description: "5".to_string(),
            k: 2,
            m_description: "x^2 + 2".to_string(),
            g: F52::from_coeffs(g_coeffs),
            q: BigInt::from_u64(24),
        };

        let a = BigInt::from_u64(7);
        let b = BigInt::from_u64(11);

        let a_pub = DHFpk::<F52, 4>::compute_public_key(&params, &a);
        let b_pub = DHFpk::<F52, 4>::compute_public_key(&params, &b);

        let exp_a_pub = F52::from_coeffs([BigInt::from_u64(3), BigInt::from_u64(3)]); // 3 + 3x
        let exp_b_pub = F52::from_coeffs([BigInt::from_u64(3), BigInt::from_u64(2)]); // 3 + 2x
        let exp_s = F52::from_coeffs([BigInt::from_u64(1), BigInt::from_u64(4)]); // 1 + 4x

        assert_eq!(a_pub, exp_a_pub);
        assert_eq!(b_pub, exp_b_pub);

        let s1 = DHFpk::<F52, 4>::compute_shared_secret(&params, &a, &b_pub);
        let s2 = DHFpk::<F52, 4>::compute_shared_secret(&params, &b, &a_pub);

        assert_eq!(s1, s2);
        assert_eq!(s1, exp_s);
    }
}
