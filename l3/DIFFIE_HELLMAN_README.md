# Diffie-Hellman Key Exchange Implementation

## Overview

This implementation provides a comprehensive Diffie-Hellman (DH) key exchange protocol across multiple algebraic structures:

1. **Classic prime field F_p** - Traditional DH over integers modulo a prime
2. **Binary extension field F_2^k** - DH over binary fields (characteristic 2)
3. **Extended prime field F_p^k** - DH over extension fields (p ≥ 3)
4. **Elliptic curves** - ECDH over F_p, F_2^k, and F_p^k

## Running the Examples

```bash
cargo run --example diffie_hellman
```

## Protocol Description

### Phase 1: Key Generation

Each party generates:
- **Private key (sk)**: A random integer from Z_q (where q is the order of the generator)
- **Public key (pk)**: Computed as g^sk (for multiplicative groups) or [sk]G (for elliptic curves)

### Phase 2: Key Agreement

Each party computes the shared secret:
- **Shared secret (ss)**: Computed as epk^sk where epk is the other party's public key
- For elliptic curves: SS = [sk]EPK

Both parties arrive at the same shared secret without transmitting it over the network.

## Domain Parameters

Domain parameters describe the algebraic structure being used:

### F_p (Prime Field)
- `p`: The prime modulus
- `g`: The generator element in F_p
- `q`: The order of the subgroup generated by g (should be prime)

### F_2^k (Binary Field)
- `k`: Extension degree
- `m`: Irreducible polynomial coefficients (bit string)
- `g`: The generator element in F_2^k
- `q`: The order of the subgroup

### F_p^k (Extension Field)
- `p`: The prime modulus
- `k`: Extension degree  
- `m`: Irreducible polynomial coefficients over F_p
- `g`: The generator element in F_p^k
- `q`: The order of the subgroup

### Elliptic Curves
- Underlying field (F_p, F_2^k, or F_p^k)
- Curve coefficients `a` and `b`
- Generator point `G` with coordinates in the field
- Order `q` of the subgroup generated by G

## Implementation Details

### Trait Hierarchy

```rust
pub trait DHDomainParameters: Clone + Debug {
    type Generator: Clone + Debug;
    fn order(&self) -> u64;
    fn generator(&self) -> Self::Generator;
}

pub trait DiffieHellman {
    type Params: DHDomainParameters;
    type PrivateKey: Clone + Debug;
    type PublicKey: Clone + Debug + PartialEq;
    type SharedSecret: Clone + Debug + PartialEq;
    
    fn generate_private_key(params: &Self::Params, random_value: u64) -> Self::PrivateKey;
    fn compute_public_key(params: &Self::Params, private_key: &Self::PrivateKey) -> Self::PublicKey;
    fn compute_shared_secret(...) -> Self::SharedSecret;
}
```

### Implementations

- **DHFp<F>**: DH over prime fields
- **DHF2k<F>**: DH over binary fields
- **DHFpk<F>**: DH over extension fields
- **DHEC<F>**: Elliptic Curve DH

## Security Considerations

### Critical Requirements

1. **Order q must be prime**: The generator's order should be prime for DDH-security
2. **Subgroup generation**: For DDH-security, g should generate a subgroup (not the full group)
3. **Cryptographic RNG**: In production, use a cryptographically secure random number generator (CSPRNG), not simple random values
4. **Timing attacks**: The elliptic curve scalar multiplication uses the Montgomery ladder for constant-time execution

### Important Notes

- The example uses simple random values for demonstration only
- In production systems:
  - Use proper CSPRNG (e.g., `rand::rngs::OsRng`)
  - Validate all public keys before use
  - Use appropriate parameter sizes (e.g., 256-bit for ECC, 2048-bit for prime field DH)
  - Consider using established curves like NIST P-256, Curve25519, etc.

## Example Results

The example demonstrates successful key exchange for:
- ✓ F_97 (prime field)
- ✓ F_2^8 (binary field with AES polynomial)
- ✓ F_5^2 (extension field)
- Elliptic curves (conceptual demonstration)

All field-based implementations produce matching shared secrets between Alice and Bob.

## Elliptic Curve Notes

The elliptic curve implementation uses constant-time scalar multiplication (Montgomery ladder) to prevent timing side-channel attacks. This is critical for cryptographic security.

For production elliptic curve usage:
- Use well-established curves with known security properties
- Ensure the generator point has prime order
- Validate all points before operations
- Consider using projective coordinates for better performance

## Interoperability Testing

To test interoperability:
1. Run the example with different random values
2. Verify that both parties compute the same shared secret
3. Test with partners using compatible implementations

The implementation is generic and works with any field type implementing `FieldElement`.

## Code Organization

- `src/diffie_hellman.rs`: Core DH protocol implementations
- `examples/diffie_hellman.rs`: Comprehensive examples for all variants
- `src/field/`: Field implementations (prime, binary, extension)
- `src/elliptic_curve.rs`: Elliptic curve group operations

## Mathematical Background

### Discrete Logarithm Problem

DH security relies on the computational difficulty of the discrete logarithm problem:
- Given g, g^x, and modulus, it's hard to find x
- This holds for finite fields and elliptic curves

### Group Properties

All implementations work over groups with:
- Closure under the group operation
- Associativity
- Identity element
- Inverse elements

### DDH Assumption

The Decisional Diffie-Hellman (DDH) assumption states that:
- Given (g, g^a, g^b, g^c), it's hard to determine if c = ab
- This requires g to generate a subgroup of prime order q

## References

- Diffie-Hellman Key Exchange (original paper, 1976)
- NIST SP 800-56A: Recommendation for Pair-Wise Key-Establishment Schemes
- RFC 3526: More Modular Exponential (MODP) Diffie-Hellman groups
- RFC 7748: Elliptic Curves for Security (Curve25519, Curve448)

## Future Enhancements

Potential improvements:
1. Support for larger integer types (BigInt-based private keys)
2. Point compression for elliptic curves
3. Batch verification for multiple public keys
4. Integration with standard parameter sets (RFC groups, NIST curves)
5. Key derivation functions (KDF) for post-processing shared secrets
